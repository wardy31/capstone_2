{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isTensor3D, isTensor4D } from '../utils';\n/**\r\n * Extracts the tensors of the image regions containing the detected faces.\r\n * Useful if you want to compute the face descriptors for the face images.\r\n * Using this method is faster then extracting a canvas for each face and\r\n * converting them to tensors individually.\r\n *\r\n * @param imageTensor The image tensor that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns Tensors of the corresponding image region for each detected face.\r\n */\nexport function extractFaceTensors(imageTensor, detections) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n        throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\n      }\n      if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n        throw new Error('extractFaceTensors - batchSize > 1 not supported');\n      }\n      return [2 /*return*/, tf.tidy(function () {\n        var _a = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0),\n          imgHeight = _a[0],\n          imgWidth = _a[1],\n          numChannels = _a[2];\n        var boxes = detections.map(function (det) {\n          return det instanceof FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;\n        }).map(function (box) {\n          return box.clipAtImageBorders(imgWidth, imgHeight);\n        });\n        var faceTensors = boxes.map(function (_a) {\n          var x = _a.x,\n            y = _a.y,\n            width = _a.width,\n            height = _a.height;\n          return tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]);\n        });\n        return faceTensors;\n      })];\n    });\n  });\n}","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,EAAE,MAAM,uBAAuB;AAG3C,SAASC,aAAa,QAAQ,0BAA0B;AACxD,SAASC,UAAU,EAAEC,UAAU,QAAQ,UAAU;AAEjD;;;;;;;;;;AAUA,OAAM,SAAgBC,kBAAkB,CACtCC,WAAsC,EACtCC,UAAuC;;;MAGvC,IAAI,CAACJ,UAAU,CAACG,WAAW,CAAC,IAAI,CAACF,UAAU,CAACE,WAAW,CAAC,EAAE;QACxD,MAAM,IAAIE,KAAK,CAAC,2DAA2D,CAAC;;MAG9E,IAAIJ,UAAU,CAACE,WAAW,CAAC,IAAIA,WAAW,CAACG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;QACvD,MAAM,IAAID,KAAK,CAAC,kDAAkD,CAAC;;MAGrE,sBAAOP,EAAE,CAACS,IAAI,CAAC;QACP,iEAA6F;UAA5FC,iBAAS;UAAEC,gBAAQ;UAAEC,mBAAuE;QAEnG,IAAMC,KAAK,GAAGP,UAAU,CAACQ,GAAG,CAC1B,aAAG;UAAI,UAAG,YAAYb,aAAa,GAC/Bc,GAAG,CAACC,OAAO,CAACL,QAAQ,EAAED,SAAS,CAAC,CAACO,GAAG,GACpCF,GAAG;QAFA,CAEA,CACR,CACED,GAAG,CAAC,aAAG;UAAI,UAAG,CAACI,kBAAkB,CAACP,QAAQ,EAAED,SAAS,CAAC;QAA3C,CAA2C,CAAC;QAE1D,IAAMS,WAAW,GAAGN,KAAK,CAACC,GAAG,CAAC,UAACM,EAAuB;cAArBC,QAAC;YAAEC,QAAC;YAAEC,gBAAK;YAAEC,kBAAM;UAClD,SAAE,CAACC,OAAO,CAACpB,WAAW,CAACqB,IAAI,CAAChB,SAAS,EAAEC,QAAQ,EAAEC,WAAW,CAAC,EAAE,CAACU,CAAC,EAAED,CAAC,EAAE,CAAC,CAAC,EAAE,CAACG,MAAM,EAAED,KAAK,EAAEX,WAAW,CAAC,CAAC;QAAvG,CAAuG,CACxG;QAED,OAAOO,WAAW;MACpB,CAAC,CAAC","names":["tf","FaceDetection","isTensor3D","isTensor4D","extractFaceTensors","imageTensor","detections","Error","shape","tidy","imgHeight","imgWidth","numChannels","boxes","map","det","forSize","box","clipAtImageBorders","faceTensors","_a","x","y","width","height","slice3d","as3D"],"sourceRoot":"","sources":["../../../src/dom/extractFaceTensors.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}